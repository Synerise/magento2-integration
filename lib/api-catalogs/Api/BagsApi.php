<?php
/**
 * BagsApi
 * PHP version 7.2
 *
 * @category Class
 * @package  Synerise\CatalogsApiClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Items-collector API Reference
 *
 * This is API for Catalogs
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: marcin.stelmach@synerise.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.1.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Synerise\CatalogsApiClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Synerise\CatalogsApiClient\ApiException;
use Synerise\CatalogsApiClient\Configuration;
use Synerise\CatalogsApiClient\HeaderSelector;
use Synerise\CatalogsApiClient\ObjectSerializer;

/**
 * BagsApi Class Doc Comment
 *
 * @category Class
 * @package  Synerise\CatalogsApiClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BagsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addBag
     *
     * Add catalog
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBag $add_bag add_bag (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\InlineResponse2001
     */
    public function addBag($add_bag)
    {
        list($response) = $this->addBagWithHttpInfo($add_bag);
        return $response;
    }

    /**
     * Operation addBagWithHttpInfo
     *
     * Add catalog
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBag $add_bag (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBagWithHttpInfo($add_bag)
    {
        $request = $this->addBagRequest($add_bag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addBagAsync
     *
     * Add catalog
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBag $add_bag (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBagAsync($add_bag)
    {
        return $this->addBagAsyncWithHttpInfo($add_bag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBagAsyncWithHttpInfo
     *
     * Add catalog
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBag $add_bag (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBagAsyncWithHttpInfo($add_bag)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2001';
        $request = $this->addBagRequest($add_bag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBag'
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBag $add_bag (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addBagRequest($add_bag)
    {
        // verify the required parameter 'add_bag' is set
        if ($add_bag === null || (is_array($add_bag) && count($add_bag) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_bag when calling addBag'
            );
        }

        $resourcePath = '/bags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($add_bag)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($add_bag));
            } else {
                $httpBody = $add_bag;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addBagWithItem
     *
     * Add Bag with Item
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBagWithItem $add_bag_with_item add_bag_with_item (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function addBagWithItem($add_bag_with_item)
    {
        list($response) = $this->addBagWithItemWithHttpInfo($add_bag_with_item);
        return $response;
    }

    /**
     * Operation addBagWithItemWithHttpInfo
     *
     * Add Bag with Item
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBagWithItem $add_bag_with_item (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function addBagWithItemWithHttpInfo($add_bag_with_item)
    {
        $request = $this->addBagWithItemRequest($add_bag_with_item);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation addBagWithItemAsync
     *
     * Add Bag with Item
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBagWithItem $add_bag_with_item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBagWithItemAsync($add_bag_with_item)
    {
        return $this->addBagWithItemAsyncWithHttpInfo($add_bag_with_item)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addBagWithItemAsyncWithHttpInfo
     *
     * Add Bag with Item
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBagWithItem $add_bag_with_item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addBagWithItemAsyncWithHttpInfo($add_bag_with_item)
    {
        $returnType = 'bool';
        $request = $this->addBagWithItemRequest($add_bag_with_item);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addBagWithItem'
     *
     * @param  \Synerise\CatalogsApiClient\Model\AddBagWithItem $add_bag_with_item (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addBagWithItemRequest($add_bag_with_item)
    {
        // verify the required parameter 'add_bag_with_item' is set
        if ($add_bag_with_item === null || (is_array($add_bag_with_item) && count($add_bag_with_item) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_bag_with_item when calling addBagWithItem'
            );
        }

        $resourcePath = '/internal/bags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($add_bag_with_item)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($add_bag_with_item));
            } else {
                $httpBody = $add_bag_with_item;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBagById
     *
     * Delete catalog
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\InlineResponse2004
     */
    public function deleteBagById($catalog_id)
    {
        list($response) = $this->deleteBagByIdWithHttpInfo($catalog_id);
        return $response;
    }

    /**
     * Operation deleteBagByIdWithHttpInfo
     *
     * Delete catalog
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBagByIdWithHttpInfo($catalog_id)
    {
        $request = $this->deleteBagByIdRequest($catalog_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\InlineResponse2004' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\InlineResponse2004', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2004';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\InlineResponse2004',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBagByIdAsync
     *
     * Delete catalog
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBagByIdAsync($catalog_id)
    {
        return $this->deleteBagByIdAsyncWithHttpInfo($catalog_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBagByIdAsyncWithHttpInfo
     *
     * Delete catalog
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBagByIdAsyncWithHttpInfo($catalog_id)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2004';
        $request = $this->deleteBagByIdRequest($catalog_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBagById'
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteBagByIdRequest($catalog_id)
    {
        // verify the required parameter 'catalog_id' is set
        if ($catalog_id === null || (is_array($catalog_id) && count($catalog_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $catalog_id when calling deleteBagById'
            );
        }

        $resourcePath = '/bags/{catalogId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($catalog_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catalogId' . '}',
                ObjectSerializer::toPathValue($catalog_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBagByIds
     *
     * Delete catalogs
     *
     * @param  string[] $request_body request_body (optional)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\InlineResponse2002
     */
    public function deleteBagByIds($request_body = null)
    {
        list($response) = $this->deleteBagByIdsWithHttpInfo($request_body);
        return $response;
    }

    /**
     * Operation deleteBagByIdsWithHttpInfo
     *
     * Delete catalogs
     *
     * @param  string[] $request_body (optional)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBagByIdsWithHttpInfo($request_body = null)
    {
        $request = $this->deleteBagByIdsRequest($request_body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\InlineResponse2002' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\InlineResponse2002', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2002';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\InlineResponse2002',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteBagByIdsAsync
     *
     * Delete catalogs
     *
     * @param  string[] $request_body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBagByIdsAsync($request_body = null)
    {
        return $this->deleteBagByIdsAsyncWithHttpInfo($request_body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBagByIdsAsyncWithHttpInfo
     *
     * Delete catalogs
     *
     * @param  string[] $request_body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBagByIdsAsyncWithHttpInfo($request_body = null)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2002';
        $request = $this->deleteBagByIdsRequest($request_body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBagByIds'
     *
     * @param  string[] $request_body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteBagByIdsRequest($request_body = null)
    {

        $resourcePath = '/bags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($request_body)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBagById
     *
     * Get catalog info
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\InlineResponse2001
     */
    public function getBagById($catalog_id)
    {
        list($response) = $this->getBagByIdWithHttpInfo($catalog_id);
        return $response;
    }

    /**
     * Operation getBagByIdWithHttpInfo
     *
     * Get catalog info
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBagByIdWithHttpInfo($catalog_id)
    {
        $request = $this->getBagByIdRequest($catalog_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\InlineResponse2001' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\InlineResponse2001', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2001';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\InlineResponse2001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBagByIdAsync
     *
     * Get catalog info
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBagByIdAsync($catalog_id)
    {
        return $this->getBagByIdAsyncWithHttpInfo($catalog_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBagByIdAsyncWithHttpInfo
     *
     * Get catalog info
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBagByIdAsyncWithHttpInfo($catalog_id)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2001';
        $request = $this->getBagByIdRequest($catalog_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBagById'
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBagByIdRequest($catalog_id)
    {
        // verify the required parameter 'catalog_id' is set
        if ($catalog_id === null || (is_array($catalog_id) && count($catalog_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $catalog_id when calling getBagById'
            );
        }

        $resourcePath = '/bags/{catalogId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($catalog_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catalogId' . '}',
                ObjectSerializer::toPathValue($catalog_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBagByIdInternal
     *
     * Get bag by id
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\Bag
     */
    public function getBagByIdInternal($catalog_id)
    {
        list($response) = $this->getBagByIdInternalWithHttpInfo($catalog_id);
        return $response;
    }

    /**
     * Operation getBagByIdInternalWithHttpInfo
     *
     * Get bag by id
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\Bag, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBagByIdInternalWithHttpInfo($catalog_id)
    {
        $request = $this->getBagByIdInternalRequest($catalog_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\Bag' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\Bag', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\Bag';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\Bag',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBagByIdInternalAsync
     *
     * Get bag by id
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBagByIdInternalAsync($catalog_id)
    {
        return $this->getBagByIdInternalAsyncWithHttpInfo($catalog_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBagByIdInternalAsyncWithHttpInfo
     *
     * Get bag by id
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBagByIdInternalAsyncWithHttpInfo($catalog_id)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\Bag';
        $request = $this->getBagByIdInternalRequest($catalog_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBagByIdInternal'
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBagByIdInternalRequest($catalog_id)
    {
        // verify the required parameter 'catalog_id' is set
        if ($catalog_id === null || (is_array($catalog_id) && count($catalog_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $catalog_id when calling getBagByIdInternal'
            );
        }

        $resourcePath = '/internal/bags/{catalogId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($catalog_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catalogId' . '}',
                ObjectSerializer::toPathValue($catalog_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBags
     *
     * Get catalogs
     *
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\InlineResponse200
     */
    public function getBags($search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        list($response) = $this->getBagsWithHttpInfo($search_by, $order_by, $offset, $limit);
        return $response;
    }

    /**
     * Operation getBagsWithHttpInfo
     *
     * Get catalogs
     *
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBagsWithHttpInfo($search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        $request = $this->getBagsRequest($search_by, $order_by, $offset, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\InlineResponse200' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\InlineResponse200', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse200';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\InlineResponse200',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBagsAsync
     *
     * Get catalogs
     *
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBagsAsync($search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        return $this->getBagsAsyncWithHttpInfo($search_by, $order_by, $offset, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBagsAsyncWithHttpInfo
     *
     * Get catalogs
     *
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBagsAsyncWithHttpInfo($search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse200';
        $request = $this->getBagsRequest($search_by, $order_by, $offset, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBags'
     *
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBagsRequest($search_by = null, $order_by = null, $offset = null, $limit = null)
    {

        $resourcePath = '/bags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($search_by !== null) {
            if('form' === 'form' && is_array($search_by)) {
                foreach($search_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['searchBy'] = $search_by;
            }
        }
        // query params
        if ($order_by !== null) {
            if('form' === 'form' && is_array($order_by)) {
                foreach($order_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['orderBy'] = $order_by;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBagsByBusinessProfile
     *
     * Get bags by Business Profile
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\Bag[]
     */
    public function getBagsByBusinessProfile($bp_id, $search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        list($response) = $this->getBagsByBusinessProfileWithHttpInfo($bp_id, $search_by, $order_by, $offset, $limit);
        return $response;
    }

    /**
     * Operation getBagsByBusinessProfileWithHttpInfo
     *
     * Get bags by Business Profile
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\Bag[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getBagsByBusinessProfileWithHttpInfo($bp_id, $search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        $request = $this->getBagsByBusinessProfileRequest($bp_id, $search_by, $order_by, $offset, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\Bag[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\Bag[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\Bag[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\Bag[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBagsByBusinessProfileAsync
     *
     * Get bags by Business Profile
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBagsByBusinessProfileAsync($bp_id, $search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        return $this->getBagsByBusinessProfileAsyncWithHttpInfo($bp_id, $search_by, $order_by, $offset, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBagsByBusinessProfileAsyncWithHttpInfo
     *
     * Get bags by Business Profile
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBagsByBusinessProfileAsyncWithHttpInfo($bp_id, $search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\Bag[]';
        $request = $this->getBagsByBusinessProfileRequest($bp_id, $search_by, $order_by, $offset, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBagsByBusinessProfile'
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $search_by A search string. You can search the catalogs by their name or the first or last name of the author. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBagsByBusinessProfileRequest($bp_id, $search_by = null, $order_by = null, $offset = null, $limit = null)
    {
        // verify the required parameter 'bp_id' is set
        if ($bp_id === null || (is_array($bp_id) && count($bp_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bp_id when calling getBagsByBusinessProfile'
            );
        }

        $resourcePath = '/internal/bags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($bp_id !== null) {
            if('form' === 'form' && is_array($bp_id)) {
                foreach($bp_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['bpId'] = $bp_id;
            }
        }
        // query params
        if ($search_by !== null) {
            if('form' === 'form' && is_array($search_by)) {
                foreach($search_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['searchBy'] = $search_by;
            }
        }
        // query params
        if ($order_by !== null) {
            if('form' === 'form' && is_array($order_by)) {
                foreach($order_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['orderBy'] = $order_by;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItemsByBagInternal
     *
     * Get items by bag
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key Item key of item (product) (optional)
     * @param  string $search_by A search string. The search takes all key values into account. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     * @param  int $last_modified_gt epoch time in seconds. Filter items which lastModified is greater than value (optional)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\Item[]
     */
    public function getItemsByBagInternal($catalog_id, $item_key = null, $search_by = null, $order_by = null, $offset = null, $limit = null, $last_modified_gt = null)
    {
        list($response) = $this->getItemsByBagInternalWithHttpInfo($catalog_id, $item_key, $search_by, $order_by, $offset, $limit, $last_modified_gt);
        return $response;
    }

    /**
     * Operation getItemsByBagInternalWithHttpInfo
     *
     * Get items by bag
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key Item key of item (product) (optional)
     * @param  string $search_by A search string. The search takes all key values into account. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     * @param  int $last_modified_gt epoch time in seconds. Filter items which lastModified is greater than value (optional)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\Item[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemsByBagInternalWithHttpInfo($catalog_id, $item_key = null, $search_by = null, $order_by = null, $offset = null, $limit = null, $last_modified_gt = null)
    {
        $request = $this->getItemsByBagInternalRequest($catalog_id, $item_key, $search_by, $order_by, $offset, $limit, $last_modified_gt);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\Item[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\Item[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\Item[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\Item[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemsByBagInternalAsync
     *
     * Get items by bag
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key Item key of item (product) (optional)
     * @param  string $search_by A search string. The search takes all key values into account. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     * @param  int $last_modified_gt epoch time in seconds. Filter items which lastModified is greater than value (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemsByBagInternalAsync($catalog_id, $item_key = null, $search_by = null, $order_by = null, $offset = null, $limit = null, $last_modified_gt = null)
    {
        return $this->getItemsByBagInternalAsyncWithHttpInfo($catalog_id, $item_key, $search_by, $order_by, $offset, $limit, $last_modified_gt)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemsByBagInternalAsyncWithHttpInfo
     *
     * Get items by bag
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key Item key of item (product) (optional)
     * @param  string $search_by A search string. The search takes all key values into account. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     * @param  int $last_modified_gt epoch time in seconds. Filter items which lastModified is greater than value (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemsByBagInternalAsyncWithHttpInfo($catalog_id, $item_key = null, $search_by = null, $order_by = null, $offset = null, $limit = null, $last_modified_gt = null)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\Item[]';
        $request = $this->getItemsByBagInternalRequest($catalog_id, $item_key, $search_by, $order_by, $offset, $limit, $last_modified_gt);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemsByBagInternal'
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key Item key of item (product) (optional)
     * @param  string $search_by A search string. The search takes all key values into account. (optional)
     * @param  string $order_by The parameter to order the results by. Order is always ascending. (optional)
     * @param  int $offset The offset for the search. For example, if your &#x60;limit&#x60; is 10 and you want to retrieve the third page of items, set the offset to 20. Items with indexes 20 to 29 are returned (the first item on the first page has the index 0). (optional)
     * @param  int $limit The maximum number of items to include in the response (optional)
     * @param  int $last_modified_gt epoch time in seconds. Filter items which lastModified is greater than value (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getItemsByBagInternalRequest($catalog_id, $item_key = null, $search_by = null, $order_by = null, $offset = null, $limit = null, $last_modified_gt = null)
    {
        // verify the required parameter 'catalog_id' is set
        if ($catalog_id === null || (is_array($catalog_id) && count($catalog_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $catalog_id when calling getItemsByBagInternal'
            );
        }

        $resourcePath = '/internal/bags/{catalogId}/items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($item_key !== null) {
            if('form' === 'form' && is_array($item_key)) {
                foreach($item_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['itemKey'] = $item_key;
            }
        }
        // query params
        if ($search_by !== null) {
            if('form' === 'form' && is_array($search_by)) {
                foreach($search_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['searchBy'] = $search_by;
            }
        }
        // query params
        if ($order_by !== null) {
            if('form' === 'form' && is_array($order_by)) {
                foreach($order_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['orderBy'] = $order_by;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($last_modified_gt !== null) {
            if('form' === 'form' && is_array($last_modified_gt)) {
                foreach($last_modified_gt as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['lastModifiedGt'] = $last_modified_gt;
            }
        }


        // path params
        if ($catalog_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catalogId' . '}',
                ObjectSerializer::toPathValue($catalog_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getItemsCSV
     *
     * Get all items as CSV file
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getItemsCSV($catalog_id)
    {
        list($response) = $this->getItemsCSVWithHttpInfo($catalog_id);
        return $response;
    }

    /**
     * Operation getItemsCSVWithHttpInfo
     *
     * Get all items as CSV file
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getItemsCSVWithHttpInfo($catalog_id)
    {
        $request = $this->getItemsCSVRequest($catalog_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'string';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getItemsCSVAsync
     *
     * Get all items as CSV file
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemsCSVAsync($catalog_id)
    {
        return $this->getItemsCSVAsyncWithHttpInfo($catalog_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getItemsCSVAsyncWithHttpInfo
     *
     * Get all items as CSV file
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getItemsCSVAsyncWithHttpInfo($catalog_id)
    {
        $returnType = 'string';
        $request = $this->getItemsCSVRequest($catalog_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getItemsCSV'
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getItemsCSVRequest($catalog_id)
    {
        // verify the required parameter 'catalog_id' is set
        if ($catalog_id === null || (is_array($catalog_id) && count($catalog_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $catalog_id when calling getItemsCSV'
            );
        }

        $resourcePath = '/bags/{catalogId}/csv';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($catalog_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catalogId' . '}',
                ObjectSerializer::toPathValue($catalog_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/csv']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/csv'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getKeysByBag
     *
     * Get catalog keys
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\CatalogsApiClient\Model\InlineResponse2003
     */
    public function getKeysByBag($catalog_id)
    {
        list($response) = $this->getKeysByBagWithHttpInfo($catalog_id);
        return $response;
    }

    /**
     * Operation getKeysByBagWithHttpInfo
     *
     * Get catalog keys
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\CatalogsApiClient\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getKeysByBagWithHttpInfo($catalog_id)
    {
        $request = $this->getKeysByBagRequest($catalog_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Synerise\CatalogsApiClient\Model\InlineResponse2003' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Synerise\CatalogsApiClient\Model\InlineResponse2003', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2003';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\CatalogsApiClient\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getKeysByBagAsync
     *
     * Get catalog keys
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKeysByBagAsync($catalog_id)
    {
        return $this->getKeysByBagAsyncWithHttpInfo($catalog_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getKeysByBagAsyncWithHttpInfo
     *
     * Get catalog keys
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getKeysByBagAsyncWithHttpInfo($catalog_id)
    {
        $returnType = '\Synerise\CatalogsApiClient\Model\InlineResponse2003';
        $request = $this->getKeysByBagRequest($catalog_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getKeysByBag'
     *
     * @param  string $catalog_id ID of the catalog (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getKeysByBagRequest($catalog_id)
    {
        // verify the required parameter 'catalog_id' is set
        if ($catalog_id === null || (is_array($catalog_id) && count($catalog_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $catalog_id when calling getKeysByBag'
            );
        }

        $resourcePath = '/bags/{catalogId}/keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($catalog_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catalogId' . '}',
                ObjectSerializer::toPathValue($catalog_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation internalGetDetalItemsByBusinessProfile
     *
     * Get detail items by Business Profile
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $catalog_name Catalog Name (required)
     * @param  string $key Key (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function internalGetDetalItemsByBusinessProfile($bp_id, $catalog_name, $key)
    {
        list($response) = $this->internalGetDetalItemsByBusinessProfileWithHttpInfo($bp_id, $catalog_name, $key);
        return $response;
    }

    /**
     * Operation internalGetDetalItemsByBusinessProfileWithHttpInfo
     *
     * Get detail items by Business Profile
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $catalog_name Catalog Name (required)
     * @param  string $key Key (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function internalGetDetalItemsByBusinessProfileWithHttpInfo($bp_id, $catalog_name, $key)
    {
        $request = $this->internalGetDetalItemsByBusinessProfileRequest($bp_id, $catalog_name, $key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation internalGetDetalItemsByBusinessProfileAsync
     *
     * Get detail items by Business Profile
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $catalog_name Catalog Name (required)
     * @param  string $key Key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalGetDetalItemsByBusinessProfileAsync($bp_id, $catalog_name, $key)
    {
        return $this->internalGetDetalItemsByBusinessProfileAsyncWithHttpInfo($bp_id, $catalog_name, $key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation internalGetDetalItemsByBusinessProfileAsyncWithHttpInfo
     *
     * Get detail items by Business Profile
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $catalog_name Catalog Name (required)
     * @param  string $key Key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function internalGetDetalItemsByBusinessProfileAsyncWithHttpInfo($bp_id, $catalog_name, $key)
    {
        $returnType = 'object';
        $request = $this->internalGetDetalItemsByBusinessProfileRequest($bp_id, $catalog_name, $key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'internalGetDetalItemsByBusinessProfile'
     *
     * @param  int $bp_id Business Profile Id (required)
     * @param  string $catalog_name Catalog Name (required)
     * @param  string $key Key (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function internalGetDetalItemsByBusinessProfileRequest($bp_id, $catalog_name, $key)
    {
        // verify the required parameter 'bp_id' is set
        if ($bp_id === null || (is_array($bp_id) && count($bp_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bp_id when calling internalGetDetalItemsByBusinessProfile'
            );
        }
        // verify the required parameter 'catalog_name' is set
        if ($catalog_name === null || (is_array($catalog_name) && count($catalog_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $catalog_name when calling internalGetDetalItemsByBusinessProfile'
            );
        }
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling internalGetDetalItemsByBusinessProfile'
            );
        }

        $resourcePath = '/internal/itemDetail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($bp_id !== null) {
            if('form' === 'form' && is_array($bp_id)) {
                foreach($bp_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['bpId'] = $bp_id;
            }
        }
        // query params
        if ($catalog_name !== null) {
            if('form' === 'form' && is_array($catalog_name)) {
                foreach($catalog_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['catalogName'] = $catalog_name;
            }
        }
        // query params
        if ($key !== null) {
            if('form' === 'form' && is_array($key)) {
                foreach($key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['key'] = $key;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadItems
     *
     * Add items from CSV
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key The name of the CSV column that contains unique identifiers (required)
     * @param  \SplFileObject $file CSV file (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function uploadItems($catalog_id, $item_key, $file)
    {
        list($response) = $this->uploadItemsWithHttpInfo($catalog_id, $item_key, $file);
        return $response;
    }

    /**
     * Operation uploadItemsWithHttpInfo
     *
     * Add items from CSV
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key The name of the CSV column that contains unique identifiers (required)
     * @param  \SplFileObject $file CSV file (required)
     *
     * @throws \Synerise\CatalogsApiClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadItemsWithHttpInfo($catalog_id, $item_key, $file)
    {
        $request = $this->uploadItemsRequest($catalog_id, $item_key, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadItemsAsync
     *
     * Add items from CSV
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key The name of the CSV column that contains unique identifiers (required)
     * @param  \SplFileObject $file CSV file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadItemsAsync($catalog_id, $item_key, $file)
    {
        return $this->uploadItemsAsyncWithHttpInfo($catalog_id, $item_key, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadItemsAsyncWithHttpInfo
     *
     * Add items from CSV
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key The name of the CSV column that contains unique identifiers (required)
     * @param  \SplFileObject $file CSV file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadItemsAsyncWithHttpInfo($catalog_id, $item_key, $file)
    {
        $returnType = 'bool';
        $request = $this->uploadItemsRequest($catalog_id, $item_key, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadItems'
     *
     * @param  string $catalog_id ID of the catalog (required)
     * @param  string $item_key The name of the CSV column that contains unique identifiers (required)
     * @param  \SplFileObject $file CSV file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadItemsRequest($catalog_id, $item_key, $file)
    {
        // verify the required parameter 'catalog_id' is set
        if ($catalog_id === null || (is_array($catalog_id) && count($catalog_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $catalog_id when calling uploadItems'
            );
        }
        // verify the required parameter 'item_key' is set
        if ($item_key === null || (is_array($item_key) && count($item_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $item_key when calling uploadItems'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling uploadItems'
            );
        }

        $resourcePath = '/bags/{catalogId}/items/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($catalog_id !== null) {
            $resourcePath = str_replace(
                '{' . 'catalogId' . '}',
                ObjectSerializer::toPathValue($catalog_id),
                $resourcePath
            );
        }

        // form params
        if ($item_key !== null) {
            $formParams['itemKey'] = ObjectSerializer::toFormValue($item_key);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\try_fopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
